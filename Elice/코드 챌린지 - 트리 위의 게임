/*
    아이디어 : 동적 계획법으로 상향식 접근으로 최적의 플레이 하향식 (재귀DFS)

    리프노드에서 root까지 올라가면서 dp에 저장
    dp[v] : v정점에서 양수거나 0이면 선공 승, 음수면 후공 승
          : 리프노트 부터 root까지 올라가면서 점수를 저장 
            부모 정점에서는 자식 노드 점수가 상대가 획득한 점수임으로 자식노드가 가장 작은 것을 선택
*/
import java.util.*;
import java.io.*;
class Main {
    static List<Integer>[] graph;
    static long[] dp;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int n = Integer.parseInt(br.readLine());
        graph = new ArrayList[n+1];
        dp = new long[n+1];
        for(int i=1;i<=n;i++){
            graph[i] = new ArrayList<>();
        }
        for(int i=0;i<n-1;i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int from = Integer.parseInt(st.nextToken());
            int to = Integer.parseInt(st.nextToken());
            graph[from].add(to);
            graph[to].add(from);
        }
        
        dfs(1, 0); // root 노드 부터 갔다가 돌아올 때 dp 사용
        for(int i=1;i<=n;i++){
            if(dp[i]>=0)sb.append(1);
            else sb.append(0);
            sb.append('\n');
        }
        System.out.print(sb);
    }
    public static void dfs(int vertex, int parents){
        long minValue = Long.MAX_VALUE;
        for(int next : graph[vertex]){
            if(parents==next) continue;  // 왔던 길을 다시 가지 않기 위해 부모 정점은 제거
            dfs(next, vertex);
            minValue = Math.min(minValue, dp[next]);  // 다음 turn이 적은 점수를 얻기 위해 작은 점수를 선택(최적 선택)
        }
        // 리프노트면 정점번호를 점수로 획득
        if(graph[vertex].size()==1) dp[vertex] = vertex;  // 왕복 간선임으로 0이 아닌 1 (parents는 있으니까)
        else{
            // 현재 획득할 점수 - 자식의 점수 가장 작은 점수
            dp[vertex] = vertex - minValue;
        }
    }
}
